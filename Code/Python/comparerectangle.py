# -*- coding: utf-8 -*-
"""compareRECTANGLE.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10Jw5EfVUOYIfUlA92VLp0kFRc_sNaF-D
"""

import matplotlib as mpl
from mpl_toolkits import mplot3d
import numpy as np
import matplotlib.pyplot as plt
from scipy.special import kn
from scipy.special import kvp
from scipy.interpolate import griddata
from matplotlib import cm
mpl.rcParams['legend.fontsize'] = 10

def extract_data_SE(filename):
  """
  Extracts the vertex data from a dump file created by
  surface evolver.
  """
  verticies_flag = False
  point_data = []
  parameters = []
  with open(filename,'r') as data:
    for line in data:
      try:  
        line = line.split()
        marker = line[0]
        
        # Find where verticies end
        if marker == "edges": 
          verticies_flag = False
          break

        # Extract data of verticies
        elif verticies_flag == True: 
          line = [float(x) for x in line[1:4]]
          #if line == [0,0,0]:  continue
          point_data.append(line)

        # Find where the verticies section starts
        elif marker == "vertices": 
          verticies_flag = True

        # Extract parameters
        elif marker == "PARAMETER":
          parameters.append(float(line[3]))
        elif marker == "GRAVITY_CONSTANT:":
          parameters.append(float(line[1]))

      except IndexError:
        continue

  point_data = np.array(point_data) # np arrays are better
  return point_data, parameters

def hexp(x,alpha,l_c,w):
  return w*np.sin(alpha)*np.exp(-(x-w*np.cos(alpha))/l_c)

def hharry(x,alpha,l_c,w):
  a = 16/3 * np.exp(2*w*np.cos(alpha)/l_c)
  b = -16/3*w*np.sin(alpha) * np.exp(3*w*np.cos(alpha)/l_c)
  t = -b/2 + np.sqrt((b/2)**2+(a/3)**3)
  u = -b/2 - np.sqrt((b/2)**2+(a/3)**3)
  A = np.sign(t)*abs(t)**(1/3) + np.sign(u)*abs(u)**(1/3)
  return A*np.exp(-(x)/l_c) + 3/16 * A**3 * np.exp(-3*x/l_c)

def hdom(x,alpha,l_c,w):
  expo = (w-x)/l_c
  t1 = alpha*w*np.exp(expo)
  t2 = (alpha**3)*(w/6+0.5*w**2+(3/16)*w**3)*np.exp(expo)
  t3 = (3/16)*(alpha**3)*(w**3)*np.exp(3*expo)
  return t1-t2+t3


def side(x,y,alpha,l_c,h):
  return x * np.tan(alpha) * np.exp(-(y-h)/l_c)

def absDif(z1,z2,z_max):
  return abs((z1-z2)/z_max)*100

from numpy.lib.type_check import mintypecode
from numpy.core.arrayprint import DatetimeFormat
point_data, parameters = extract_data_SE('/content/drive/MyDrive/Part III Project/Surface Evolver/rectangular/7rec.txt')
x, y, z_SE = point_data.T

w,h, R_out, alpha, gamma, rho, g = parameters

l_c = (gamma/(rho*g))**0.5 # Capillary length sqrt(gamma/rho g)

z_hexp = hexp(x, alpha, l_c, w)
z_max = w * np.sin(alpha)

xs = np.linspace(w, w+0.01, 100)
ys = 0#np.linspace(0, 2*np.pi, 100) # Angles
X, Y = np.meshgrid(xs, ys)

grid_se = griddata(np.array([x,y]).T, z_SE, (X, Y), method='cubic')

print(l_c)

l_c_min_h = 0
"""
error_h = 10e10
for l_cc in  np.linspace(l_c-0.9*l_c,l_c+0.2*l_c,1000):
  z_h= hexp(xs,alpha,l_cc,w)
  
  z_dif = absDif(grid_se[0],z_h,z_max)
  if sum(z_dif**2) < error_h:
    error_h = sum(z_dif**2)
    l_c_min_h = l_cc
"""
lc_start = l_c-0.7*l_c
lc_end = l_c + 0.3*l_c
for i in range(1,100):
  z_dif1 = sum(absDif(grid_se[0],hexp(xs,alpha,lc_start,w),z_max)**2)
  z_dif2 = sum(absDif(grid_se[0],hexp(xs,alpha,lc_end,w),z_max)**2)
  lc_mid = 0.5*(lc_start+lc_end)
  if z_dif1 < z_dif2:
    lc_end = lc_mid
  else:
    lc_start = lc_mid


print(lc_mid)
fig, ax = plt.subplots(figsize=(20,10))

ax.plot(1000*(xs-w),grid_se[0])

ax.plot(1000*(xs-w),hexp(xs,alpha,l_c,w),'.')
ax.plot(1000*(xs-w),hexp(xs,alpha,lc_mid,w),'.')

ax.set_xlabel('r-R_in / mm')
ax.set_ylabel('h / mm')
ax.legend(['SE','exp','exp_min'])
ax.set_ylim(0,z_max)

plt.show()

# square sum
# N's tested
# 0.002713214724955537
N_tested = [0.5,1,1.5,2,2.5,3,3.5,4,5,6,8,10,9,7]

# Max error taken from above graph
error_tested_dom = [0.00270406169158946,0.0027014756222938363,0.002699505697789993,0.0026955619735191975,0.0026912794809675813,0.0026859036755012182,0.002679611536429388,0.0026723275528149825,0.0026514198681718516,0.0026295978154059806,0.002574523852428595,0.0025097236205838718,0.0025396062855534036,0.002605636487011352] 


m, A = np.polyfit(np.log(N_tested), np.log(error_tested_dom), 1)
print('Fitted exponent:', m,A)

fig, ax = plt.subplots()

ax.plot(N_tested, (error_tested_dom), 'k+',ms=10)

ax.set_ylabel('Fitted capillary length /mm')
ax.set_xlabel('alpha / deg')
#ax.legend(['harry','dom'])

plt.show();

xs = np.linspace(w, w+0.01, 100)
ys = 0#np.linspace(0, 2*np.pi, 100) # Angles
X, Y = np.meshgrid(xs, ys)

grid_se = griddata(np.array([x,y]).T, z_SE, (X, Y), method='cubic')


fig, ax = plt.subplots(figsize=(20,10))

ax.plot(1000*(xs-w),grid_se[0])

ax.plot(1000*(xs-w),hexp(xs,alpha,l_c,w),'.')

ax.set_xlabel('r-R_in / mm')
ax.set_ylabel('h / mm')
ax.legend(['SE','Dom','Dom_min','Harry','Harry_min'])

plt.show()

fig, ax = plt.subplots(figsize=(10,10))

q= ax.tripcolor(x, y, z_SE)

cbar=fig.colorbar(q)
ax.axis('scaled')
#ax.set(xlim=(0-0.02, 0+0.02), ylim=(h-0.01,h+0.01));
ax.set(xlim=(-R_out, R_out), ylim=(-R_out, R_out));

xs = np.linspace(-w, w, 100)
ys = h+0.005#np.linspace(0, 2*np.pi, 100) # Angles
X, Y = np.meshgrid(xs, ys)

grid_se = griddata(np.array([x,y]).T, z_SE, (X, Y), method='cubic')


fig, ax = plt.subplots(figsize=(20,10))

ax.plot(1000*(xs),grid_se[0])


ax.plot(1000*(xs),side(xs,ys,alpha,l_c,h),'-')

ax.set_xlabel('r-R_in / mm')
ax.set_ylabel('h / mm')
ax.legend(['SE','Dom','Dom_min','Harry','Harry_min'])

plt.show()